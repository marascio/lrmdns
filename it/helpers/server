#!/usr/bin/env bash
# Server lifecycle management for lrmdns integration tests

# Check if running on Windows (Git Bash, Cygwin, WSL, etc.)
is_windows() {
    [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || "$OSTYPE" == "win32" ]]
}

# Get a unique port for this test (based on process ID)
# This allows parallel test execution without port conflicts
get_unique_port() {
    local base_port=20000
    # Use process ID for uniqueness across all parallel tests
    # Each test runs in its own subprocess, so $$ is globally unique
    echo $((base_port + ($$ % 10000)))
}

# Start lrmdns server
# Args: $1 = config file (will be modified with dynamic port), $2 = port (optional, auto-assigned if not provided)
start_server() {
    local source_config="${1:-fixtures/configs/basic.yaml}"
    local port="${2:-$(get_unique_port)}"
    local log_file="$BATS_TEST_TMPDIR/server.log"
    local temp_config="$BATS_TEST_TMPDIR/config.yaml"

    # Kill any existing instance for this test
    stop_server || true

    # If port was auto-assigned, create a temp config with the dynamic port
    if [ "$#" -lt 2 ]; then
        # Calculate API port (DNS port + 10000)
        local api_port=$((port + 10000))

        # Replace both DNS port and API port in config file
        sed -e "s/listen: \"127\.0\.0\.1:[0-9]*\"/listen: \"127.0.0.1:${port}\"/" \
            -e "s/api_listen: \"127\.0\.0\.1:[0-9]*\"/api_listen: \"127.0.0.1:${api_port}\"/" \
            "$source_config" > "$temp_config"
        local config="$temp_config"
        export LRMDNS_API_PORT="$api_port"
    else
        local config="$source_config"
    fi

    # Start server in background
    LRMDNS_BIN="${LRMDNS_BIN:-../target/release/lrmdns}"
    $LRMDNS_BIN "$config" > "$log_file" 2>&1 &
    LRMDNS_PID=$!

    # Wait for server to start
    wait_for_server "$port"

    export LRMDNS_PID
    export LRMDNS_PORT="$port"
    export LRMDNS_LOG="$log_file"
    export LRMDNS_CONFIG="$config"
}

# Stop lrmdns server
stop_server() {
    if [ -n "$LRMDNS_PID" ]; then
        kill "$LRMDNS_PID" 2>/dev/null || true
        # Wait for process to actually terminate
        local attempts=0
        while kill -0 "$LRMDNS_PID" 2>/dev/null && [ $attempts -lt 10 ]; do
            sleep 0.1
            attempts=$((attempts + 1))
        done
        # Force kill if still alive
        kill -9 "$LRMDNS_PID" 2>/dev/null || true
        unset LRMDNS_PID
    fi

    # DO NOT use pkill here - it kills servers from other parallel tests!
    # Each test manages its own server via LRMDNS_PID
}

# Wait for server to be ready
# Args: $1 = port
wait_for_server() {
    local port="${1:-$LRMDNS_PORT}"
    local max_attempts=50
    local attempt=0

    # Poll the port until the server responds or we timeout
    while [ $attempt -lt $max_attempts ]; do
        # Try to connect to the port using nc or by sending a DNS query
        # A successful response (even REFUSED) means the server is up
        if nc -z -w 1 127.0.0.1 "$port" 2>/dev/null; then
            # Give server a bit more time to fully initialize
            sleep 0.1
            return 0
        fi
        sleep 0.1
        attempt=$((attempt + 1))
    done

    echo "WARNING: Server did not respond on port $port after $max_attempts attempts" >&2
    return 1
}

# Reload server zones (SIGHUP)
# Note: Only works on Unix systems. Windows does not support SIGHUP.
reload_server() {
    if is_windows; then
        echo "WARNING: reload_server() is not supported on Windows (requires SIGHUP)" >&2
        return 1
    fi

    if [ -n "$LRMDNS_PID" ]; then
        kill -HUP "$LRMDNS_PID"
        sleep 0.5  # Give server time to reload
    fi
}

# Get server metrics (SIGUSR1)
# Note: Only works on Unix systems. Windows does not support SIGUSR1.
dump_metrics() {
    if is_windows; then
        echo "WARNING: dump_metrics() is not supported on Windows (requires SIGUSR1)" >&2
        return 1
    fi

    if [ -n "$LRMDNS_PID" ]; then
        kill -USR1 "$LRMDNS_PID"
        sleep 0.1
    fi
}

# Query metrics API
# Args: $1 = API port (defaults to LRMDNS_API_PORT or 8080)
get_metrics() {
    local api_port="${1:-${LRMDNS_API_PORT:-8080}}"
    curl -s "http://127.0.0.1:${api_port}/metrics"
}

# Cleanup on exit
cleanup_server() {
    stop_server
    # BATS automatically cleans up BATS_TEST_TMPDIR - no manual file deletion needed
}
